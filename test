local NEBULAUTH_BASE_URL = "https://api.nebulauth.com"
local NEBULAUTH_API_TOKEN = "mk_at_dhHGH-SOHFp2P-C1SH5TkVI5KZMwBOf_6-CjymOS_0Y"
local NEBULAUTH_SIGNING_SECRET = "mk_sig_6eC7un_9nlb01Qcx3j_PQmpqBDxeQNLYUmG5yNIMhy0"
local HEARTBEAT_INTERVAL = 300

local function sha256_hex(data)
    if not crypt or not crypt.hash then
        return nil
    end
    return crypt.hash(data, "sha256")
end

local function hex_to_bytes(hex)
    if not hex then
        return nil
    end
    return (hex:gsub("..", function(cc)
        return string.char(tonumber(cc, 16))
    end))
end

local function bytes_to_hex(data)
    return (data:gsub(".", function(c)
        return string.format("%02x", string.byte(c))
    end))
end

local function hmac_sha256_hex(key, message)
    if not key or not message then
        return nil
    end
    if not bit32 or not bit32.bxor then
        return nil
    end

    local block_size = 64
    if #key > block_size then
        local key_hash = sha256_hex(key)
        if not key_hash then
            return nil
        end
        key = hex_to_bytes(key_hash)
    end
    if #key < block_size then
        key = key .. string.rep("\0", block_size - #key)
    end

    local o_key_pad = {}
    local i_key_pad = {}
    for i = 1, block_size do
        local kb = string.byte(key, i)
        o_key_pad[i] = string.char(bit32.bxor(kb, 0x5c))
        i_key_pad[i] = string.char(bit32.bxor(kb, 0x36))
    end

    local inner = table.concat(i_key_pad) .. message
    local inner_hash = sha256_hex(inner)
    if not inner_hash then
        return nil
    end

    local outer = table.concat(o_key_pad) .. hex_to_bytes(inner_hash)
    return sha256_hex(outer)
end


local HttpService = game:GetService("HttpService")

local function signed_post_auth_verify(body_obj, auth_mode, auth_token, signing_key)
    local body_string = HttpService:JSONEncode(body_obj)
    local body_hash = sha256_hex(body_string)
    local timestamp_ms = tostring(DateTime.now().UnixTimestampMillis)
    local nonce = HttpService:GenerateGUID(false)

    local canonical = table.concat({
        "POST",
        "/auth/verify",
        timestamp_ms,
        nonce,
        body_hash,
    }, "\n")
    local signature = hmac_sha256_hex(signing_key, canonical)

    local headers = {
        ["Content-Type"] = "application/json",
        ["Authorization"] = "Bearer " .. auth_token,
        ["X-Timestamp"] = timestamp_ms,
        ["X-Nonce"] = nonce,
        ["X-Signature"] = signature,
    }

    if auth_mode == "bearer" then
        headers["X-Body-Sha256"] = body_hash
    end

    local hwid = gethwid and gethwid()
    if hwid and hwid ~= "" then
        headers["X-Hwid"] = hwid
    end

    local res = request({
        Url = NEBULAUTH_BASE_URL .. "/api/v1/auth/verify",
        Method = "POST",
        Headers = headers,
        Body = body_string,
    })

    if not res then
        return nil, "No response"
    end

    local ok, data = pcall(function()
        return HttpService:JSONDecode(res.Body)
    end)
    if not ok then
        return nil, "Invalid JSON response"
    end

    return {
        statusCode = res.StatusCode,
        data = data,
    }, nil
end

local function signed_post_keys_verify(body_obj, auth_mode, auth_token, signing_key)
    local body_string = HttpService:JSONEncode(body_obj)
    local body_hash = sha256_hex(body_string)
    local timestamp_ms = tostring(DateTime.now().UnixTimestampMillis)
    local nonce = HttpService:GenerateGUID(false)

    local canonical = table.concat({
        "POST",
        "/keys/verify",
        timestamp_ms,
        nonce,
        body_hash,
    }, "\n")
    local signature = hmac_sha256_hex(signing_key, canonical)

    local headers = {
        ["Content-Type"] = "application/json",
        ["Authorization"] = "Bearer " .. auth_token,
        ["X-Timestamp"] = timestamp_ms,
        ["X-Nonce"] = nonce,
        ["X-Signature"] = signature,
    }

    if auth_mode == "bearer" then
        headers["X-Body-Sha256"] = body_hash
    end

    local hwid = gethwid and gethwid()
    if hwid and hwid ~= "" then
        headers["X-Hwid"] = hwid
    end

    local res = request({
        Url = NEBULAUTH_BASE_URL .. "/api/v1/keys/verify",
        Method = "POST",
        Headers = headers,
        Body = body_string,
    })

    if not res then
        return nil, "No response"
    end

    local ok, data = pcall(function()
        return HttpService:JSONDecode(res.Body)
    end)
    if not ok then
        return nil, "Invalid JSON response"
    end

    return {
        statusCode = res.StatusCode,
        data = data,
    }, nil
end

local function verify_with_pop(end_user_key)

    local bootstrap, err = signed_post_auth_verify(
        {
            key = end_user_key,
            requestId = HttpService:GenerateGUID(false),
            hwid = gethwid and gethwid() or nil,
        },
        "bearer",
        NEBULAUTH_API_TOKEN,
        NEBULAUTH_SIGNING_SECRET
    )

    if not bootstrap then
        return nil, err
    end

    local accessToken = bootstrap.data and bootstrap.data.accessToken
    local popKey = bootstrap.data and bootstrap.data.popKey

    if not accessToken or not popKey then
        return nil, "PoP bootstrap failed (missing accessToken/popKey)"
    end

    local verify, verifyErr = signed_post_keys_verify(
        {
            key = end_user_key,
            requestId = HttpService:GenerateGUID(false),
        },
        "pop",
        accessToken,
        popKey
    )

    if not verify then
        return nil, verifyErr
    end

    if verify.data and verify.data.valid == true then
        return verify.data, nil
    end

    return nil, (verify.data and verify.data.reason) or "INVALID_KEY"
end

local data, err = verify_with_pop(getgenv().key)

if err then
    error("PoP verify failed: " .. tostring(err))
elseif data and data.valid then
    print("PoP verify ok:", data.keyId)
else
    error("PoP verify denied")
end

local function sleep(sec)
    if sec <= 0 then return end
    if task and task.wait then
        task.wait(sec)
        return
    end
    if wait then
        wait(sec)
        return
    end
    local t0 = os.clock()
    while os.clock() - t0 < sec do end
end

local function heartbeat_once()
    local ok, res_or_err = pcall(function()
        return signed_post_auth_verify(
            {
                key = getgenv().key,
                requestId = HttpService:GenerateGUID(false),
            },
            "bearer",
            NEBULAUTH_API_TOKEN,
            NEBULAUTH_SIGNING_SECRET
        )
    end)

    if not ok then
        return false, tostring(res_or_err)
    end

    local res = res_or_err
    if not res or res.statusCode ~= 200 then
        return false, "bad response"
    end

    if res.data and res.data.valid == false then
        return false, "invalid"
    end

    return true
end

local heartbeat_running = true

coroutine.wrap(function()
    sleep(1)

    while heartbeat_running do
        local ok, heartbeat_err = heartbeat_once()
        if not ok then
            error("Heartbeat failed: " .. tostring(heartbeat_err))
            return
        end

        local elapsed = 0
        while elapsed < HEARTBEAT_INTERVAL and heartbeat_running do
            local step = math.min(10, HEARTBEAT_INTERVAL - elapsed)
            sleep(step)
            elapsed += step
        end
    end
end)()
